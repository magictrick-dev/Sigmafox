// --- Sigmafox CLI Parser Utility ---------------------------------------------
//
// Written by Chris DeJong Oct. 2024 / Northern Illinois University
//
//      The command line utility parses and validates command line arguments
//      and appropriately sets the ApplicationParameters to necessary constants.
//      The end-point function, parse, returns true/false depending if the CLI
//      specification matches the arguments that were passed in.
//      
// CLI Context-Free Grammar
//
//      cli          : (argument)* source_file (argument)*
//      source_file  : PATH
//      argument     : parameter | switch
//      switch       : "-"(FLAG*)
//      parameter    : "--output-name" PATH | "--output-directory" PATH
//
// The command-line parser converts all CLI arguments (excluding the first, by
// convention) to higher order class objects. These are then parsed and validated,
// modifying ApplicationParameters as needed.
//
// For parsing, we concern ourselves with 3 types of CLI argument types: parameters,
// switches, and values. Values are the most dense of the three and also contain an
// error type which is potentially generated by any of the those types. Switches
// and parameters generate errors if they do not parse to specification, while
// values generate errors only if they don't match as a numerical constant, a
// alpha-numeric/single-quote/double-quote, or a file path. Numerical constants
// are of three distinct types: integer, real, hex, or storage-format. Storage
// format is basically just [integer][b/B,kb/KB,mb/MB,gb/GB,tb/TB]. At parse time,
// these are converted back to numbers, in bytes.
//
// The parser first classifies (tokenizes) the CLI arguments and stores them.
// The grammar is then verified using a trivial recursive descent algorithm that
// handles the specification requirements of parameters and switches. Given that
// the list of arguments conform to the CLI CFG described above, then the return
// value of the parser is true. However, if it fails, then it will return false.
//
// CLI::parse(argc, argv) --> (classify()) --> (conform()) -> return true/false
//
// -----------------------------------------------------------------------------
#ifndef SIGAMFOX_UTILITIES_CLI_H
#define SIGAMFOX_UTILITIES_CLI_H
#include <string>
#include <vector>
#include <environment.h>
#include <definitions.h>

namespace Sigmafox
{

    // --- CLIArgument ---------------------------------------------------------
    //
    // Serves as the virtual interface for all CLI argument types.
    //

    enum class CLIArgumentType
    {
        Error,
        Switch,
        Parameter,
        Numerical,
        String,
        Filepath,
    };

    class CLIArgument
    {
        public:
            inline          CLIArgument(i32 index, ccptr argument);
            inline virtual ~CLIArgument() = 0;

            inline i32      get_index() const;
            inline ccptr    get_argument() const;
            inline CLIArgumentType get_type() const;

        protected:
            CLIArgumentType type    = CLIArgumentType::Error;
            i32     raw_index       = 0;
            ccptr   raw_argument    = nullptr;
    };

    inline CLIArgument::
    CLIArgument(i32 index, ccptr argument)
    {
        this->raw_index = index;
        this->raw_argument = argument;
    }

    inline i32 CLIArgument::
    get_index() const
    {
        return this->raw_index;
    }

    inline ccptr CLIArgument::
    get_argument() const
    {
        return this->raw_argument;
    }

    inline CLIArgumentType CLIArgument::
    get_type() const
    {
        return this->type;
    }

    // --- CLIValue : CLIArgument ----------------------------------------------
    //
    // Arguments that don't evaluate to switches or parameters are classified
    // as values. This is catch-all format (that includes error values).
    //

    class CLIValue : public CLIArgument
    {

        public:
            static inline CLIArgument* parse(i32 index, ccptr argument);
            static inline CLIArgument* error(i32 index, ccptr argument);

        protected:
            inline              CLIValue(i32 argc, ccptr argument);
            inline virtual     ~CLIValue();

    };

    inline CLIValue::
    CLIValue(i32 index, ccptr argument) : CLIArgument(index, argument)
    {
        
    }

    inline CLIValue::
    ~CLIValue()
    {

    }

    inline CLIArgument* CLIValue::
    parse(i32 index, ccptr argument)
    {

    }

    inline CLIArgument* CLIValue::
    error(i32 index, ccptr argument)
    {

    }

    // --- CLISwitch : CLIArgument ---------------------------------------------
    //
    // Switches corresponds to the "-[A-Za-z]*" specification.
    //

    class CLISwitch : public CLIArgument
    {

        public:
            static inline CLIArgument* parse(i32 index, ccptr argument);

        protected:
            inline              CLISwitch(i32 argc, ccptr argument);
            inline virtual     ~CLISwitch();

    };

    inline CLISwitch::
    CLISwitch(i32 index, ccptr argument) : CLIArgument(index, argument)
    {
        
    }

    inline CLISwitch::
    ~CLISwitch()
    {

    }

    inline CLIArgument* CLISwitch::
    parse(i32 index, ccptr argument)
    {

        // These conditions should be checked by CLI::parse() and therefore must
        // always be true.
        u64 string_length = strlen(argument);
        SF_ASSERT(string_length >= 2);
        SF_ASSERT(argument[0] == '-');

        b32 valid_format = true;
        for (u64 i = 1; i < string_length; ++i)
        {

            if (!isalpha(argument[i]))
            {
                valid_format = false;
                break;
            }

        }

        if (valid_format)
        {
            CLISwitch *result = new CLISwitch(index, argument);
            return result;
        }

        else
        {
            CLIArgument *result = CLIValue::error(index, argument);
            return result;
        }

    }

    // --- CLI -----------------------------------------------------------------
    //
    // The global container for CLI and the parser implementation. This class
    // contains only a single static implementation function called CLI::parse()
    // which is responsible for classifying arguments and conforming it to the CFG.
    //

    class CLI
    {

        public:
            static inline bool  parse(i32 argc, cptr* argv);

        protected:
            inline              CLI();
            inline virtual     ~CLI();
            static inline CLI&  self();

            static inline CLIArgument* classify();
            static inline CLIArgument* classify_switch();
            static inline CLIArgument* classify_parameter();
            static inline CLIArgument* classify_value();

        protected:
            std::vector<CLIArgument*> arguments;
            i32     argi;
            i32     argc;
            cptr   *argv;
            
    };

    inline CLIArgument* CLI::
    classify_switch()
    {

    }

    inline CLIArgument* CLI::
    classify_parameter()
    {

    }

    inline CLIArgument* CLI::
    classify_value()
    {

    }

    inline CLIArgument* CLI::
    classify()
    {

        CLI& self = CLI::self();
        ccptr argument = self.argv[self.argi];
        u64 length = strlen(argument);

        // We need only the first and second characters to find which type it is.
        char first = argument[0];
        char second = argument[1];
        if (first == '-' && second == '-') return self.classify_parameter();
        else if (first == '-' && second != '-') return self.classify_switch();
        else return self.classify_value();

    }

    inline bool CLI::
    parse(i32 argc, cptr* argv)
    {

        // Get self and set initial values.
        CLI& self = CLI::self();
        self.argc = argc;
        self.argv = argv;
        self.argi = 0;

        // Classify all the arguments.
        for (i32 i = 1; i < argc; ++i)
        {
            self.argi = i;
            self.arguments.push_back(self.classify());
        }

    }

    inline CLI& CLI::
    self()
    {

        static CLI *instance = nullptr;
        if (instance == nullptr)
        {
            instance = new CLI();
        }

        return *instance;

    }

    inline CLI::
    CLI()
    {

    }

    inline CLI::
    ~CLI()
    {

    }

};

#endif
